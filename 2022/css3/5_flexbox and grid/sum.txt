â˜…â–¶â–ºâ–¬â€¢Â»â€ºâ–²â™¥âš ï¸ğŸ’¡Â±Ã—Ã·Â²âˆšÏ€â°â‰ â‰ˆâ‰¤â‰¥Ã˜âˆâœ“âœ—âœ– â‚¬ â† â†’ â†‘ â†“ â‡†â™ªÂ©â’¹ãŠ¿â€ â‚±â€¦
â˜…layout:
 â–¶flex: (rel to writing-mode|direction) â‡†mainAxis âœ–crossAxis
  â–º.container{ â€¢display: inline-|flex;        
   â–¬f-flow:<fd>? <fw>?;
    â€¢f-directionâ‡†|wrapâœ–s?e: rowâ’¹?column|nowrapâ’¹?wrap |-reverse;
   â–¬place-content: both|<acâœ–> <jcâ‡†>;/*align item-boxâ†’container*/
    â€¢justify-contentâ‡†: flex-|startâ’¹?endâ‰ S19s3| left?rightâ‰ s3| center| space-between?around(gap=2edge)?evenly;
      â€ºalign items relâ†’container, overridedBy{margin<flex}.
    â€¢align-contentâœ–(*f-wrapâ‰ unwrap): stretchâ’¹| flex-|s?eâ‰ S19s3| center| space-between?around?evenly;
      â€ºalign all track-linesâ†’container.
   â–¬align-itemsâœ–: stretchâ’¹|baseline|center| flex?self-|s?eâ‰ S19s3
    â€ºalign all itemsâ†’itsLines, self-s?e basedOn .item{direction}
  â–º.item{ â€¢order: Â±#0d;
   â–¬align-selfâœ–:autoâ’¹|stretch|baseline|center| f?self-|s?eâ‰ S19s3
    â€ºalign individual itemâ†’itsLine, override{align-items}
   â–¬margin-s:auto'fillGap; â‡†m-s>jc, âœ–m-s>a-self>a-items
   â–¬flex: initialâ’¹01A| auto11A| none00A| g s b(g10|11b|gs0|g1b);
     â€ºmin-w?h > basis > shtink > w?h, max-* > basis > grow > w?h
    â€¢f-grow: #.0d;              override{margin>justify-content}
      â€ºfill before=after main-size(basis>w?h) gap.
    â€¢f-shrink: #1d; if space unfit wrap lineâ†’multiShortLines
    â€¢f-basis: autoâ’¹â†’{w?h,main-size}| length| %(main-axis);
      â€ºif main-size>L% return auto, &if main-size>w?h content overlap its box (fix: overflow|-wrap| word-break)
 â–¶grid:
  â™¥.container{ â€¢display: inline-|grid;
   â–ºgrid: <gt>| auto-flow dense? <track-size>â€¦/<gt-columns>| <gt-rows>/auto-flow dense? <track-size>â€¦;
    â–¬g-template: noneâ’¹| <gt-rows>/<gt-columns>|
      [ln? 'area1 â€¦' <track-size>? ln?]â€¦/<track-listâ‰ repeat>;
      â€ºlineNames: [ln1 ln2â€¦]; ln=[â‰ 0~9][a~Z|0~9|-|_|\â™ª]?â€¦;
        if(top&left-lineâ†’[a-start], b&r-lineâ†’[a-end]) {a=area}
     â€¢gt-rows?columns: noneâ’¹| <track-list>| <auto-track-list>;
      Â»track-list: [ln? <track-size?repeat>]â€¦ ln?
       â€ºtrack-size: <b>| fit-content(L%)| minmax(<bâ‰ fr>, <b>)
        _breadth: L%|auto|fr|min?max-content
        _auto: minmax(min-content,max-content)
         auto=min?max-content inside minmax()
        _fit-content(X): min(max-content, max(min-content, X))
       â€ºtrack-repeat: repeat(#, <track-listâ‰ repeat>)
      Â»auto-t-list: [ln? <fixed-size?repeat>]â€¦ ln? <auto-repeat>
       â€ºfixed-size: L%| minmax(L%,<b>|<bâ‰ fr>,L%)
       â€ºfixed-r: repeat(#,[ln? <fixed-size>]â€¦ ln?);
       â€ºauto-r: repeat(auto-fill?fit,[ln? <fixed-size>]â€¦ ln?)
     â€¢gt-areas:
    â–¬g-auto-flow: rowâ’¹?column dense?(unorder holes-fill);
    â–¬g-auto-rows?columns: <track-size(autoâ’¹)>â€¦;
   â–ºplace-content:
    â–¬justify?align-content
   â–ºg-|gap
   â–ºplace-items:
    â–¬j?a-items
  â™¥.item{           â€¢order: Â±#0d;          â€¢z-index: autoâ’¹|Â±#;
   â–¬g-area1~4:
   â–¬g-row?column
    â€¢g-r?c-start?end:
   â–¬j?a-self:
   â–¬margin

  â€¢g-template-areas: noneâ’¹| <string1> <s2> â€¦; â€ºex: gta: 'a a b'
    â€ºstring: represent row cells= character+|.(empty);   'a a .'
    â€ºevery #rectangle area generates 4 line-names (reverse too!) 
      _top?left-line=[areaName-start], b?r-line=[areaName-end]
*alignment: â€¢place-content:<align=justify-content>| <a-c> <j-c>;
  â€¢justify?align-content: <j(+stretch)?a-content(full support)>;
    â€ºtarget column?row-track'sâ†’container.
    â€ºissue(overflow): gaps added to space-between?around?evenly
 â€¢g-|gap'a: r=c|r c; â€¢g-|row?column-gap: normal(1em)d| +length?%;
 â€¢place-items: <align=justify-items>| <a-i> <j-i>;
  â€¢j?a-items: normalâ’¹| <a-i(full-support)>| left?right(â‰ a-i);
    â€ºtarget all items-boxesâ†’areas.
    â€ºnormal=stretch'unreplaced-els, n=start'block?replaced-els.


â˜…items{ â€¢order: Â±#0d; â€¢z-index: autoâ’¹| Â±#;
*placement:
  â€¢grid-area1~4: area| r-start/c-start?/r-end?/c-end?;
  â€¢g-row?column(spanâ‰ both): <*-star> / <*-end>;
    â€¢g-row?column-start?end: autoâ’¹(=span 1)| Â±#*(-1=lastLine)| ln(Ã¸[])| span +#?ln(from opposite-lineâ‰ span to item-in?[ln])| areaName(Ã¸'', *-start:a;â†’[a-start], *-end:a;â†’[a-end]);
*alignment: â€¢place-self: <a=j-self>| <a-self> <j-self>;
  â€¢j?a-self: autoâ’¹| <j?a-i(grid)>; override{j?a-items}
    â€ºauto: based on justify?align-items values.
  â€¢margin: auto;â†’ place-self: center; override{j?a-self>j?a-i}
    â€ºm:0 auto:â†’ justify-s:center; â€ºm:auto 0:â†’ align-s:center;
    â€ºm-top:auto:â†’ align-s:end; â€ºm-bottom:auto:â†’ align-s:start;
    â€ºm-left:auto;â†’ justify-s:right; â€ºm-right:auto;â†’ j-s:left;

â˜…â˜…â˜…block-lvl & absolute-position els: â€¢place-self?items:;









â˜…float(on below): noneâ’¹| left| right; â€¢shape-margin: length| %;
  â€¢shape-outside: noneâ’¹| <img>| <shape-box>| <basic-shape>;
    â€ºshape-box: content?padding?border?margin-box; (inâ†’b-radius)
    Â»basic-shape(animated): circle(cr at p)| ellipse(hr vr at p) polygon(<fill-rule>, x1 y1,â€¦)| inset(<offset> round <b-radius>);
      â€ºfill-rule: nonzeroâ’¹| evenodd(unfill inside);
      â€ºoffset(rectangle): all|h v|t h b|t r b l; (Â±length|Â±%).
      â€ºcr|hr?vr: length| %50d| closest?farthest-side;
      â€ºposition(centerâ†’top-left): x?y| x y| hs offset vs offset;
     x?y:length|%|<side>|centerâ’¹; hs?vs:<side>; offset:length|%
  â€¢shape-image-threshold(animated): 0d~1; required by <gradient>
  â€¢#blockBelowNeighbor(unWrap){clear: noneâ’¹| left| right| both}
  â€¢issue: if all-els=f, heightâ†’0, f-els overlap container-box.
    â€ºfix: #container::after{content:'';display:block;clear:both}
    â€ºfix2: #container-box{ display:flow-root}, inclode all f-els
 *behaviors(normal flow): â€¢block-lvl els: inline-size=w=100%, and generated below etch others in new lines.
  â€¢inline els generated next to etch others, parallel to (dir=|direction:), wrap to new lines TtB to fill block-container.
  â€¢float entire el-box(+margin) relative to parent-#content-box.
  â€¢width are #requred by unReplaced-i & block-lvl els.
  â€¢margin of wraped|unWraped neighbors, collapseâ†’0.
  â€¢turn display: inline|-block|table-*;â†’ display: block;
    display: inline-flex?grid?table;â†’ display: flex|grid|table;
  â€¢block-lvl f-els mack below neighbors b-lvl-#content-box wrap.
  â€¢sameSide subsequenced floats render inline to opposite f-side
    â€ºif container width can't fit, unorder-positioned topest & closest to f-side, (nested floats cause #position issues).
â˜…clip-path: url()| <shape-box +view-box>| <basic-shape +path()>;
  â€¢apply to svg, just url(), <basic-shape> apply to html.
â˜…position(zi++): staticâ’¹| relative| absolute| fixed| sticky;
 *<side>(offset): autoâ’¹| Â±length| Â±%; (define #both Hs=w, Vs=h)
 *z-index(apply to p-els): autoâ’¹| Â±#; (high z-i overlap lower)
  â€ºauto: last el in source have z-index > previos els.
  â€¢relative: preserve original occupied space in normal-flow.
    â€ºoffset rel to original-box(top-left corner).
  â€¢absolute: apply to margin-box, remove originalSpace of nFlow
    â€ºinline-elsâ†’ behave as block-lvl-box(new container).
    Â»offset rel to closest ancestor{p:relative|absolute|fixed}
      â€ºelse it rel to html(initial containing-block)
        _issue: buttom(offset) rel to viewport(scrollable).
  â€¢fixed: as absolute, but rel to viewport, or closest ancestor{transform;perspective;filter}
    â€ºadd space at bottom of document to avoid hidden content.
  â€¢sticky: stay in its nFlow, until its origin hidin by #scroll.
    â€ºoffset rel to closest block-ancestor{overflowâ‰ none|clip},in table module rel to th|thead, v-scroll required top?bottom|both.



